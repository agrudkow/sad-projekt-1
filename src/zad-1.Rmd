---
title: "Projekt 1"
author: "Banzekulivakha Zhan, Grudkowski Artur"
date: "18 04 2021"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(rprojroot)

knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE)
```

## Zadanie 1

### Przygotowanie danych

```{r}
load_data <- function(path) {
  return(read.table(path, sep = ",", header = TRUE))
}

prepare_data <- function(df) {
  # Change col names
  col_names <- c( "TICKER", "DATE", "OPEN", "HIGH", "LOW", "CLOSE", "VOL")
  colnames(df) <- col_names

  # Filter data to suit assagnment details (transactions in second half of 2019)
  df <- df[df$DATE >= 20190701 & df$DATE <= 20191231,]
  
  return(df[order(df$DATE),])
}
```

### Dla zadanych spółek1 notowanych na WGPW, na podstawie ich notowan z drugiej połowy roku 2019 (z pliku zad1mst.zip):

### (a) wyznacz procentowe zmiany cen zamkniecia tych spółek

Zmiany procentowe są interpretowane jako zmiany zamknięcia między dwoma następującymi notowaniami w dwóch kolejnych dniach.
Wynik dla notowania *i-1* i *i* jest liczny ze wzoru: $result = (n(i - 1) - n(i)/n(i)$, gdzie *n* oznacza zbiór notowań.

```{r}
calc_close_diff <- function(dataset) {
  # Init empty vector
  close_diff <- c()

  for(i in 2:nrow(dataset)) {
    first_day_val <- dataset$CLOSE[i - 1]
    second_day_val <- dataset$CLOSE[i]

    diff <- (first_day_val - second_day_val) / first_day_val
    # Convert to percentage
    diff <- diff * 100
    close_diff <- c(close_diff, diff)
  }

  return(close_diff)
}
```

Wyniki dla spółki PLAY
```{r}
# PLAY
close_diff_play <- load_data("./data/p1mst/PLAY.mst") %>% prepare_data %>% calc_close_diff

print(close_diff_play)
```

Wyniki dla spółki LPP
```{r}
# LPP
close_diff_lpp <- load_data("./data/p1mst/LPP.mst") %>% prepare_data %>% calc_close_diff

print(close_diff_lpp)
```

### (b) zilustruj rozkłady ww. zmian (histogramy + wykresy pudełkowe)

```{r draw_plots}
draw_plots <- function(data) {
  hist(data, main="Histogram rozkłądu procentowej zmiany cen zamknięcia", xlab="Zmiana procentowa", ylab="Liczność", col="darkmagenta", breaks=50)
  boxplot(data, xlab = "Percentage increase", horizontal = TRUE)
}

```

Wykres dla spółki PLAY
```{r}
draw_plots(close_diff_play)
```

Wykres dla spółi LPP
```{r}
draw_plots(close_diff_lpp)
```

### (c) wyestymuj parametry rozkładów normalnych mogacych modelowac ww. rozkłady

```{r}
estimate_dnorm_params <- function(data) {
  return(list(mean=mean(data), sd=sd(data)))
}
```

Estymacja dla spółki PLAY
```{r}
dnorm_params_play <- estimate_dnorm_params(close_diff_play)

print(dnorm_params_play$mean)
print(dnorm_params_play$sd)
```

Estymacja dla spółki LPP
```{r}
dnorm_params_lpp <- estimate_dnorm_params(close_diff_lpp)

print(dnorm_params_lpp$mean)
print(dnorm_params_lpp$sd)
```

### (d) porównaj graficznie rozkłady modelowe z danymi
```{r}
plot_comparison <- function(data, dnorm_params, col="darkmagenta") {
  hist <- hist(data, main="Histogram rozkłądu procentowej zmiany cen zamknięcia", xlab="Zmiana procentowa", ylab="Liczność", col=col, breaks=50) 
  xfit <- seq(min(data), max(data), length = 40) 
  yfit <- dnorm(xfit, mean = dnorm_params$mean, sd = dnorm_params$sd) 
  yfit <- yfit * diff(hist$mids[1:2]) * length(data) 

  lines(xfit, yfit, col = "black", lwd = 2)
}
```
Porównanie dla spółki PLAY
```{r}
plot_comparison(close_diff_play, dnorm_params_play)
```

Porównanie dla spółki LPP
```{r}
plot_comparison(close_diff_lpp, dnorm_params_lpp)
```

## Zadanie 2

### Przygotowanie danych

```{r}
load_data <- function(path) {
  return(read.table(path, sep = ",", header = TRUE))
}

prepare_data <- function(df) {
  # Filter data to suit assagnment details (transactions in October 2019)
  df <- df[df$date >= 191001 & df$date <= 191031,]
  
  # Add id column
  data <- tibble::rowid_to_column(df, "id")

  return (data)
}
```


### Na podstawie danych z pazdziernika 2019 (z pliku zad2csv new.zip) dotyczacych zadanej spółki:

### (a) zilustruj jak wolumen transakcji rozkłada sie pomiedzy 3 fazy notowan: otwarcie3, notowania ciagłe4, zamkniecie z dogrywka

```{r}
extract_opening_transactions <- function(df) {
  # Select first opening transaction for each day
  first_opening_transactions <- df[df$time == 90000,] %>% group_by(date) %>% slice(1)

  # Select opening transaction
  opening_transactions <- data.frame(first_opening_transactions)

  # Select related transactions for each of first opening transactions
  for (i in 1:nrow(first_opening_transactions)) {
    result <- data.frame(df[df$date == first_opening_transactions$date[i] 
              & df$time == first_opening_transactions$time[i] 
              & df$price == first_opening_transactions$price[i] 
              & df$id != first_opening_transactions$id[i],]) # Skip transactions from first_opening_transactions

    opening_transactions <- rbind(opening_transactions, result)
  }

  return(opening_transactions[order(opening_transactions$id),])
}

extract_continous_transactions <- function(df, opening_transactions) {
  return(df[df$time <= 165100 & !(df$id %in% opening_transactions$id),])
}

extract_closing_transactions <- function(df, opening_transactions) {
  return(df[df$time >= 165900,])
}

extract_transaction_groups <- function(df) {
  opening_transactions <- extract_opening_transactions(df)
  continous_transactions <- extract_continous_transactions(df, opening_transactions)
  closing_transactions <- extract_closing_transactions(df)

  return(list(opening=opening_transactions, continous=continous_transactions, closing=closing_transactions))
}
```

```{r}
sum_volumes_by_day <- function(dataset) {
  return(dataset %>% group_by(date) %>% summarise(volume = sum(volume)))
}

```

```{r}
  transactions <- load_data("./data/p1csv_new/PGE.csv") %>% prepare_data %>% extract_transaction_groups

  opening <- data.frame(group="opening", sum_volumes_by_day(transactions$opening) %>% select(volume))
  continous <- data.frame(group="continous", sum_volumes_by_day(transactions$continous) %>% select(volume))
  closing <- data.frame(group="closing", sum_volumes_by_day(transactions$closing) %>% select(volume))

  ggplot(opening, aes(y=volume)) + geom_boxplot()
  ggplot(continous, aes(y=volume)) + geom_boxplot()
  ggplot(closing, aes(y=volume)) + geom_boxplot()

  ggplot(rbind(opening, continous, closing), aes(x=group, y=volume, fill=group)) + geom_boxplot()
```

### (b) zilustruj jak wolumen transakcji rozkłada sie w czasie notowan ciagłych
```{r}
extract_hours <- function(df) {
  for (i in 1:nrow(df)) {
     df$hour[i] = df$time[i] %/% 10000
  }

  return(df)
}
```

```{r}
sum_volumes_by_hour <- function(df) {
  return(df %>% group_by(hour) %>% summarise(volume = sum(volume)))
}
```

```{r}
volumes_sum_by_hour <- transactions$continous %>% extract_hours %>% sum_volumes_by_hour
g <- ggplot(volumes_sum_by_hour, aes(x=hour, y=volume))
g + geom_col() + labs(title = "Histogram rozkłądu sumy wolumenów dla każdej godziny")
```

### (c) Wyznacz dzień i jego 2-godzinny przedział czasu rozpoczynający się o pełnej godzinie między 10:00 a 14:00 włącznie, w którym jest najmniej sekund, w których przeprowadzane były transakcje na akcjach danej spółki.
```{r}
count_transactions_by_hour <- function(df) {
  return(df %>% group_by(date, hour) %>% summarise(n_distinct(time)))
}

transactions_by_hour <- load_data("./data/p1csv_new/PGE.csv") %>% prepare_data %>% filter(time >= 100000, time < 160000) %>% extract_hours %>% count_transactions_by_hour
names(transactions_by_hour)[3] <- "count"

#print(load_data("./data/p1csv_new/PGE.csv") %>% prepare_data %>% filter(time >= 100000, time < 160000) %>% extract_hours %>% count_transactions_by_hour)
#print(load_data("./data/p1csv_new/PGE.csv") %>% prepare_data %>% filter(time >= 100000, time <= 140000) %>% extract_hours %>% filter(date == 191028 & hour == 14))
```
```{r}
extract_min_2h_time_frame <- function(df) {
  min_trans = 99999999
  start_hour = 0
  date = 0
  for (i in 1:(nrow(df)-1)) {
    count_for_2h <- df$count[[i]] + df$count[[i+1]]
    if(count_for_2h < min_trans){
      date <- df$date[i]
      start_hour <- df$hour[i]
      min_trans <- count_for_2h
    }
  }
  
  return(list(date=date, start_hour=start_hour, min_trans=min_trans))
}

#extract_all_distinct_transactions_in_2h <- function(list_res) {
min_list <- extract_min_2h_time_frame(transactions_by_hour)
min_date <- min_list$date
start_time <- min_list$start_hour * 10000
finish_time <- start_time + 20000 # plus 2 hours
min_df <- load_data("./data/p1csv_new/PGE.csv") %>% prepare_data %>% filter(time >= start_time, time <= finish_time, date==min_date) %>% distinct(time, .keep_all = TRUE)
```


#### (i). W każdej kolejnej minucie rozważanego przedziału wyznacz liczbę sekund, w których przeprowadzane były transakcje (otrzyma się w ten sposób 120 liczb z przedziału [0, 60]),
```{r}
prepare_minutes_list_start_from <- function(start_time) {
  times <- c(as.integer(start_time / 100)) # 2 - start time
  increment <- 1
  actual_time <- times[1]
  for(i in 1:120) {
    actual_time <- actual_time + increment
    if(str_detect(actual_time, "60$")) { # next hour
      actual_time <- actual_time + 40
    }
    times <- c(times, actual_time)
  }

  return(times)
}

count_used_sec_per_min <- function(start_time, df) {
  times <- prepare_minutes_list_start_from(start_time)
  counts <- c() 
  for(i in 1:length(times)) {
    time <- times[i]
    pattern <- paste("^", time, sep = "")
    num_used_secs <- df %>% filter(str_detect(time, pattern)) %>% nrow
    counts <- c(counts, num_used_secs)
  }
  
  df_count_per_minute = data.frame(times, counts)
  
  return(df_count_per_minute)
}

```

```{r}
df_count_per_minute <- count_used_sec_per_min(start_time, min_df)
df_count_per_minute$id_time <- seq.int(0:120)

# df_count_per_minute
# TODO df_count_per_minute$times -> [0:120]

```


```{r}
ggplot(data = df_count_per_minute) +
  geom_bar(aes(x = id_time,
               y = counts),
           stat="identity") +
  scale_x_continuous(breaks=seq(0,120,5)) +
  labs(x = 'Minuta',
       y = 'Ilosc transakcyj',
       title = 'Liczba uzytych sekund na transakcje per minuty') +
  theme_bw()
# TODO jak zrobic tak zeby nie bylo takich gap'ow na wykresie ???

```


#### (ii). zamodeluj ww. liczby za pomocą rozkładu Poissona
```{r}

lambda = mean(df_count_per_minute$counts)
num_transactions <- 0:10
density <- dpois(x = num_transactions, lambda)
prob <- ppois(q = num_transactions, lambda, lower.tail = TRUE)
df <- data.frame(num_transactions, density, prob)
ggplot(df, aes(x = factor(num_transactions), y = density)) +
  geom_col() +
  geom_text(
    aes(label = round(density,2)),
    
    size = 3,
    vjust = -1
  ) +
  labs(title = "PMF and CDF of Poisson Distribution",
       x = "Liczba transakcji na minute",
       y = "Density") +
  geom_line(data = df, aes(x = num_transactions, y = prob))
```

#### (iii). porównaj rozkład modelowy z danymi.
```{r}


```
    